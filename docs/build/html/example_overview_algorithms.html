

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Overview Algorithms &mdash; PulsedJAX: Pulse-Retrieval-with-JAX 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css?v=ec38ee01" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=cb975c41"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Method-Specific Algorithms" href="example_method_specific_algorithms.html" />
    <link rel="prev" title="Overview Methods" href="example_overview_methods.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PulsedJAX: Pulse-Retrieval-with-JAX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Content</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="example_overview_methods.html">Overview Methods</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_method_specific_algorithms.html">Method-Specific Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_nonlinear_optimization.html">Nonlinear Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_advanced_things.html">Advanced Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Equations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#z-gradients">Z-Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#z-pseudo-hessian">Z-Pseudo Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#pie-gradient">PIE Gradient</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#pie-pseudo-hessian">PIE - Pseudo Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#update-nonlinear-signal">Update nonlinear Signal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Definitions_and_Formulas.html#adaptive-stepsize">Adaptive Stepsize</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="frog.html">frog</a></li>
<li class="toctree-l1"><a class="reference internal" href="chirp_scan.html">chirp_scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdp.html">tdp</a></li>
<li class="toctree-l1"><a class="reference internal" href="twodsi.html">twodsi</a></li>
<li class="toctree-l1"><a class="reference internal" href="vampire.html">vampire</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulate_trace.html">simulate_trace</a></li>
<li class="toctree-l1"><a class="reference internal" href="real_fields.html">real_fields</a><ul>
<li class="toctree-l2"><a class="reference internal" href="real_fields.chirp_scan.html">real_fields.chirp_scan</a></li>
<li class="toctree-l2"><a class="reference internal" href="real_fields.frog.html">real_fields.frog</a></li>
<li class="toctree-l2"><a class="reference internal" href="real_fields.tdp.html">real_fields.tdp</a></li>
<li class="toctree-l2"><a class="reference internal" href="real_fields.twodsi.html">real_fields.twodsi</a></li>
<li class="toctree-l2"><a class="reference internal" href="real_fields.vampire.html">real_fields.vampire</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="core.html">core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core.gradients.html">core.gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.hessians.html">core.hessians package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">utilities</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PulsedJAX: Pulse-Retrieval-with-JAX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Overview Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/example_overview_algorithms.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="overview-algorithms">
<h1>Overview Algorithms<a class="headerlink" href="#overview-algorithms" title="Link to this heading"></a></h1>
<p>Internally one can divide the implemented algorithms into two general types. Classical-Algorithms and General-Algorithms, where the former refers to algorithms that have been specifically introduced to solve the phase-retrieval problem in ultrafast optics, while the latter refers to generic optimization algorithms.<br />
The algorithms described here belong to either type. In addition several method-specific algorithms have been published and are discussed in <a class="reference internal" href="example_method_specific_algorithms.html"><span class="std std-doc">Method-Specific Algorithms</span></a>.</p>
<section id="classical-algorithms">
<h2>Classical Algorithms<a class="headerlink" href="#classical-algorithms" title="Link to this heading"></a></h2>
<section id="generalized-projection">
<h3>Generalized Projection<a class="headerlink" href="#generalized-projection" title="Link to this heading"></a></h3>
<p>Starting from an initial guess the algorithm works by constructing the nonlinear signal field <span class="math notranslate nohighlight">\(S(\theta, \omega)\)</span> (<span class="math notranslate nohighlight">\(\theta\)</span> refers to an arbitrary scanning parameter). The amplitude of this guessed signal field is replaced by the measured amplitude of the trace to yield <span class="math notranslate nohighlight">\(S'(\theta, \omega)\)</span>. Thus the signal field is projected into the space of signal fields that could produce the measured trace. The updated guess of the pulse is obtained through an iterative optimization of the Z-error.<br />
<br>
Below is a small working example of the Generalized Projection Algorithm to an SHG-FROG. Apart from the nonlinear optimization methods described in the <a class="reference internal" href="example_nonlinear_optimization.html"><span class="std std-doc">Nonlinear Optimization</span></a> section, the main tunable parameters are the number of gradient descent steps (no_steps_descent) and the step size (global_gamma).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeneralizedProjection</span>

<span class="n">gp</span> <span class="o">=</span> <span class="n">GeneralizedProjection</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>

<span class="n">gp</span><span class="o">.</span><span class="n">global_gamma</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gp</span><span class="o">.</span><span class="n">no_steps_descent</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeneralizedProjection</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">gp</span> <span class="o">=</span> <span class="n">GeneralizedProjection</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span> <span class="n">population</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;pulsedjax&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="ptychographic-iterative-engine">
<h3>Ptychographic Iterative Engine<a class="headerlink" href="#ptychographic-iterative-engine" title="Link to this heading"></a></h3>
<p>The general idea of Ptychography is to move a probe <span class="math notranslate nohighlight">\(P(\theta)\)</span> over an object <span class="math notranslate nohighlight">\(O\)</span>. The resulting signal is simply the product of the two. Thus the Ptychographic Iterative Engine (PIE) demands the nonlinear signal to be of the form <span class="math notranslate nohighlight">\(S(\theta, t) = O(t)\cdot P(\theta,t)\)</span>. This makes it suitable for most pulse characterization methods, with the exception inteferometry based methods such as i-FROG and doubleblind retrieval of 2D-SI and VAMPIRE.</p>
<p>The PIE can be described in two equivalent ways. Either as an iterative optimization of the regularized Z-error:</p>
<p><span class="math notranslate nohighlight">\(Z = \sum |S'(\theta, t) - O'(t)\cdot P(\theta, t)|^2 + \sum U(t) |O'(t) -  O(t)|^2\)</span></p>
<p>with the heuristic weighting <span class="math notranslate nohighlight">\(U(t)\)</span>.<br />
Alternatively it can be described by the weighted iterative optimization of:</p>
<p><span class="math notranslate nohighlight">\(L = \sum |\sqrt{T(\theta, \omega)} - |S(\theta, \omega)||^2\)</span></p>
<p>via</p>
<p><span class="math notranslate nohighlight">\(O'(t) = O(t) - U'(t)\cdot \frac{dL(\theta)}{dO(t)^*}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(U'\neq U\)</span> and determines the subtype of the PIE.<br />
Usually the PIE works in local iterations, where optimization steps are taken subsequently over random permutations of the measured trace along <span class="math notranslate nohighlight">\(\theta\)</span>. In this implementation an additional version performs global steps by optimizing for all measured data along <span class="math notranslate nohighlight">\(theta\)</span> simultaneously.<br />
<br>
Below is a small working example of the PIE to an SHG-FROG. Apart from the nonlinear optimization methods described in the <a class="reference internal" href="example_nonlinear_optimization.html"><span class="std std-doc">Nonlinear Optimization</span></a> section, the main tunable parameters are the PIE version, the weighting parameter <span class="math notranslate nohighlight">\(\alpha\)</span>, as well as the local and global stepsizes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">PtychographicIterativeEngine</span>

<span class="n">pie</span> <span class="o">=</span> <span class="n">PtychographicIterativeEngine</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> <span class="n">pie_method</span><span class="o">=</span><span class="s2">&quot;PIE&quot;</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">pie</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>

<span class="n">pie</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.15</span>
<span class="n">pie</span><span class="o">.</span><span class="n">local_gamma</span> <span class="o">=</span> <span class="mf">1e-1</span>
<span class="n">pie</span><span class="o">.</span><span class="n">global_gamma</span> <span class="o">=</span> <span class="mf">1e-3</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">pie</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="copra">
<h3>COPRA<a class="headerlink" href="#copra" title="Link to this heading"></a></h3>
<p>The original implementation of the Common-Pulse-Retrieval-Algorithm (COPRA) is <a class="reference external" href="https://github.com/ncgeib/pypret">pypret</a>.</p>
<p>Roughly speaking, COPRA is a combination of the Generalized-Projection (GP) and the PIE. The algorithm works in two phases. In the first phase, similar to the PIE, local iterations are performed on random permutations along <span class="math notranslate nohighlight">\(\theta\)</span>. However instead of using an PIE update, COPRA performs single steps to optimize the Z-error. After a sufficient number of local iterations COPRA switches to global iterations. A global iteration optimizes two different error quantities in an alternating fashion. These are the r-error:</p>
<p><span class="math notranslate nohighlight">\(r = \sum |T(\theta,\omega) - \mu\cdot |S(\theta,\omega)|^2|^2\)</span></p>
<p>and the Z-error. Using single gradient-descent iterations the minimization of r-error is used to obtain updated signal fields <span class="math notranslate nohighlight">\(S'(\theta,t)\)</span> which are subsequently used to update the pulse guess via the minimization of the Z-error using single gradient-descent iterations. Thus in a global iteration smooth and gradual transitions are employed over plain projections.<br />
In addition for all gradient-descent iterations COPRA estimates an optimal step size via the Polyak-Stepsize.<br />
<br>
Below is a small working example of the COPRA to an SHG-FROG. Apart from the nonlinear optimization methods described in the <a class="reference internal" href="example_nonlinear_optimization.html"><span class="std std-doc">Nonlinear Optimization</span></a> section, the main tunable parameters are the local and global stepsizes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">COPRA</span>

<span class="n">copra</span> <span class="o">=</span> <span class="n">COPRA</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">copra</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>

<span class="n">copra</span><span class="o">.</span><span class="n">local_gamma</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">copra</span><span class="o">.</span><span class="n">global_gamma</span> <span class="o">=</span> <span class="mf">0.25</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">copra</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="additional-constraint-and-momentum">
<h3>Additional Constraint and Momentum<a class="headerlink" href="#additional-constraint-and-momentum" title="Link to this heading"></a></h3>
<p>All of the Classical Algorithms, are able to incorporate the pulse-spectrum as an additional constraint. This may improve the retrieval result, but it also may cause issues if the provided spectrum and measured trace are somehow inconsistent. For doubleblind retrievals the provision of spectra for pulse and gate-pulse is necessary to avoid retrieval ambiguities.<br />
A spectrum can be incorporated in any algorithm as shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeneralizedProjection</span>

<span class="n">gp</span> <span class="o">=</span> <span class="n">GeneralizedProjection</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>

<span class="n">gp</span><span class="o">.</span><span class="n">use_measured_spectrum</span><span class="p">(</span><span class="n">frequency_spectrum</span><span class="p">,</span> <span class="n">pulse_spectrum</span><span class="p">,</span> <span class="n">pulse_or_gate</span><span class="o">=</span><span class="s2">&quot;pulse&quot;</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">global_gamma</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gp</span><span class="o">.</span><span class="n">no_steps_descent</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">final_result</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Additionally the gradient-descent like optimizations can be accelerated via the incroporation of momentum. This means that a velocity-map of the pulses is updated each iteration and used to additionally update the current guess. This can be used with any Classical Algorithm as shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeneralizedProjection</span>

<span class="n">gp</span> <span class="o">=</span> <span class="n">GeneralizedProjection</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>

<span class="n">population_size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">gp</span><span class="o">.</span><span class="n">momentum</span><span class="p">(</span><span class="n">population_size</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># requires population size to initialize arrays in the correct shape.</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="n">population_size</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">global_gamma</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gp</span><span class="o">.</span><span class="n">no_steps_descent</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">final_result</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="general-algorithms">
<h2>General Algorithms<a class="headerlink" href="#general-algorithms" title="Link to this heading"></a></h2>
<section id="differential-evolution">
<h3>Differential Evolution<a class="headerlink" href="#differential-evolution" title="Link to this heading"></a></h3>
<p>This implementation of the Differential Evolution algorithm (DE), follows the same paper as the scipy-implementation. It works by taking a parent population and creating a child population through mutations and crossover operations. A fitness evaluation then returns the population back to its original size.<br />
In addition to the standard implementation an additional crossover strategy (smooth) and an additional selection mechanism (global) have been implemented. The smooth-crossover is motivated by the fact that the population can be parametrized on a grid. Conventional crossovers (bin, exp) will introduce sharp jumps and cutoffs into the population. The smooth crossover works similar to the exp-crossover but introduces a smooth transition via a tanh() function.<br />
The additional selection mechanism is motivated by the fact that the greedy-selection performs a pair-based comparison of parent and child population. The global-selection performs a global comparison of all individuals and randomly selects the fittest individuals. This selection can be tuned via a temperature of a Fermi-Dirac-like probability distribution.<br />
<br>
Below is a small working example of the DE to an SHG-FROG. The main tunable parameters are the strategy, selection mechanism, the mutation rate, the crossover rate and in the temperature in case of a global selection.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">DifferentialEvolution</span>

<span class="n">de</span> <span class="o">=</span> <span class="n">DifferentialEvolution</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> 
                           <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;best1_bin&quot;</span><span class="p">,</span> <span class="n">selection_mechanism</span><span class="o">=</span><span class="s2">&quot;greedy&quot;</span><span class="p">,</span> 
                           <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">crossover_rate</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> 
                                          <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;bsplines_5&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;bsplines_5&quot;</span><span class="p">,</span> 
                                          <span class="n">no_funcs_amp</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">no_funcs_phase</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="lsf">
<h3>LSF<a class="headerlink" href="#lsf" title="Link to this heading"></a></h3>
<p>The Linesearch-Frog-Algorithm (LSF) is a general optimization algorithm. Despite its name. Simply speaking the algorithm performs a high-dimensional randomized bisection search. This works by selecting a random complex-valued direction. By setting the maximum pulse magnitude to one, a lower and an upper boundry can be defined. Be performing bisection search along the random direction inside the boundary, a slightly improoved pulse guess can be found.<br />
On top of the fully randomized version, in this implementation one can restrict the random directions to exhibit some degree of smoothness. However, this may not necesserily improve the algorithm performance.<br />
<br>
In addition the algorithm is not able to fully converge if one applies an additional constraint by projection onto the pulse spectrum. This is because the bisection search does not know about the spectrum. The projection and the bisection search may thus counteract each other. A possible but not implemented solution would be to seperate the pulse into a magnitude and a complex oscillatory part <span class="math notranslate nohighlight">\(\Psi\)</span> with constant magnitude one and only optimize the latter. <span class="math notranslate nohighlight">\(\left(E(\omega,\phi(\omega)) = E(\omega)\cdot \Psi(\phi(\omega))\right)\)</span><br />
<br>
Below is a small working example of the LSF to an SHG-FROG. The main tunable parameters are the number of iterations per bisection-search as well as a tuning parameter for the smoothness in case of a continuous direction search.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">LSF</span>

<span class="n">lsf</span> <span class="o">=</span> <span class="n">LSF</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">lsf</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">)</span>

<span class="n">lsf</span><span class="o">.</span><span class="n">number_of_bisection_iterations</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">lsf</span><span class="o">.</span><span class="n">random_direction_mode</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
<span class="c1"># lsf.ratio_points_for_continuous = 0.25    # only used when random_direction_mode=&quot;continuous&quot;</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">lsf</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="evosax">
<h3>Evosax<a class="headerlink" href="#evosax" title="Link to this heading"></a></h3>
<p>This “Algorithm” uses the python/jax package <a class="reference external" href="https://github.com/RobertTLange/evosax">evosax</a> to employ advanced evolutionary solvers for pulse retrieval. The availablilty of a multitude of such solvers comes at a drawback. Evosax does not respect the shape of pytrees. Internally all pytrees are flattened before being subjected to an evolutionary algorithm. This causes mixing of variables that do not necessarily should be mixed. For example the position and the magnitude of a gaussian. In this implementation precautions have been take to prevent the mixing of amplitude and phase variables. But within the phases and amplitudes evosax will happily mixing variables arbitrarily. Essentially this heavily promotes exploration over exploitation.<br />
<br>
Below is a small working example of Evosax with an SHG-FROG. One should be able to choose any evosax solver. These solvers can be tuned via their input parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">Evosax</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evosax.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">DifferentialEvolution</span> <span class="k">as</span> <span class="n">DifferentialEvolutionEvosax</span>

<span class="c1"># the evosax-solver should not be initialized</span>
<span class="n">evo</span> <span class="o">=</span> <span class="n">Evosax</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DifferentialEvolutionEvosax</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">evo</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> 
                                           <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;sigmoidal&quot;</span><span class="p">,</span> 
                                           <span class="n">no_funcs_amp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">no_funcs_phase</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="n">evo</span><span class="o">.</span><span class="n">solver_params</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># None, causes the default params to be used.</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">evo</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="autodiff">
<h3>AutoDiff<a class="headerlink" href="#autodiff" title="Link to this heading"></a></h3>
<p>This “Algorithm” uses the python/jax packages <a class="reference external" href="https://github.com/google-deepmind/optax">optax</a> and <a class="reference external" href="https://github.com/patrick-kidger/optimistix">optimistix</a> to employ their implemented optimization algorithms.<br />
<br>
Below is a small working example of AutoDiff with an SHG-FROG. One should be able to choose any optax/optimistix solver. These solvers can be tuned via their input parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">AutoDiff</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optimistix</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optax</span>


<span class="n">solver</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="c1"># solver = optimistix.LBFGS(1, 1) # the tolerances dont matter, since a fixed number of iterations is done</span>

<span class="n">ad</span> <span class="o">=</span> <span class="n">AutoDiff</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> 
                                           <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;sigmoidal&quot;</span><span class="p">,</span> 
                                           <span class="n">no_funcs_amp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">no_funcs_phase</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="additional-constraint-and-loss-function">
<h3>Additional Constraint and Loss-Function<a class="headerlink" href="#additional-constraint-and-loss-function" title="Link to this heading"></a></h3>
<p>As in the Classical Algorithms, the General Algorithms are able to incorporate the pulse-spectrum as an additional constraint. However, with the exception of LSF all implementations incorporate this constraint as a true constraint optimization. Meaning that if a spectrum is provided only the phase will be optimized. For doubleblind retrievals the provision of spectra for pulse and gate-pulse is necessary to avoid retrieval ambiguities.<br />
A spectrum can be incorporated in any algorithm as shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">AutoDiff</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optimistix</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optax</span>


<span class="n">solver</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="c1"># solver = optimistix.LBFGS(1, 1) # the tolerances dont matter, since a fixed number of iterations is done</span>

<span class="n">ad</span> <span class="o">=</span> <span class="n">AutoDiff</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">use_measured_spectrum</span><span class="p">(</span><span class="n">frequency_spectrum</span><span class="p">,</span> <span class="n">pulse_spectrum</span><span class="p">,</span> <span class="n">pulse_or_gate</span><span class="o">=</span><span class="s2">&quot;pulse&quot;</span><span class="p">)</span>
<span class="n">population</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> 
                                           <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;sigmoidal&quot;</span><span class="p">,</span> 
                                           <span class="n">no_funcs_amp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">no_funcs_phase</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="n">final_result</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Since the General Algorithms dont rely on analytic derivatives one is not restricted to a specific Error/Loss-function. By default the G-error is used:</p>
<p><span class="math notranslate nohighlight">\(G = \frac{1}{N_\theta\cdot N_\omega}\sum |T(\theta, \omega) -  |S(\theta,\omega)|^2|^2\)</span></p>
<p>However one can specify an arbitrary user-defined loss-function. This can be done as shown below, where an L1-Norm isused.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pulsedjax.frog</span><span class="w"> </span><span class="kn">import</span> <span class="n">AutoDiff</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>


<span class="k">def</span><span class="w"> </span><span class="nf">my_loss</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">measured_trace</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trace</span> <span class="o">-</span> <span class="n">measured_trace</span><span class="p">))</span>
    

<span class="n">solver</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="n">ad</span> <span class="o">=</span> <span class="n">AutoDiff</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;shg&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>

<span class="n">population</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">create_initial_population</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> 
                                           <span class="n">amp_type</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">phase_type</span><span class="o">=</span><span class="s2">&quot;sigmoidal&quot;</span><span class="p">,</span> 
                                           <span class="n">no_funcs_amp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">no_funcs_phase</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">error_metric</span> <span class="o">=</span> <span class="n">my_loss</span>
<span class="n">final_result</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="example_overview_methods.html" class="btn btn-neutral float-left" title="Overview Methods" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="example_method_specific_algorithms.html" class="btn btn-neutral float-right" title="Method-Specific Algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Till-Jakob Stehling.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>